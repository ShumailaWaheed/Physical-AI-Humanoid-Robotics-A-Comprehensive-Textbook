"use strict";(globalThis.webpackChunkai_book=globalThis.webpackChunkai_book||[]).push([[8886],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var o=s(6540);const i={},t=o.createContext(i);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(t.Provider,{value:n},e.children)}},9428:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>_,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module1-ros2/nodes-topics-services-actions","title":"Nodes, Topics, Services, Actions in ROS 2","description":"Deep Dive into ROS 2 Communication Mechanisms","source":"@site/docs/module1-ros2/nodes-topics-services-actions.md","sourceDirName":"module1-ros2","slug":"/module1-ros2/nodes-topics-services-actions","permalink":"/module1-ros2/nodes-topics-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/ShumailaWaheed/Physical-AI-Humanoid-Robotics-A-Comprehensive-Textbook/edit/main/docs/module1-ros2/nodes-topics-services-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"Chapter 4: ROS 2 Fundamentals","permalink":"/module1-ros2/ros2-fundamentals"},"next":{"title":"Chapter 6: Building ROS 2 Packages (Python)","permalink":"/module1-ros2/building-ros2-packages"}}');var i=s(4848),t=s(8453);const r={},l="Nodes, Topics, Services, Actions in ROS 2",a={},c=[{value:"Deep Dive into ROS 2 Communication Mechanisms",id:"deep-dive-into-ros-2-communication-mechanisms",level:2},{value:"1. Nodes: The Building Blocks of Your Robot Application",id:"1-nodes-the-building-blocks-of-your-robot-application",level:3},{value:"2. Topics: Asynchronous Data Streaming (Publish/Subscribe)",id:"2-topics-asynchronous-data-streaming-publishsubscribe",level:3},{value:"3. Services: Synchronous Request/Reply",id:"3-services-synchronous-requestreply",level:3},{value:"4. Actions: Asynchronous, Long-Running Tasks with Feedback",id:"4-actions-asynchronous-long-running-tasks-with-feedback",level:3},{value:"Next Steps",id:"next-steps",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"nodes-topics-services-actions-in-ros-2",children:"Nodes, Topics, Services, Actions in ROS 2"})}),"\n",(0,i.jsx)(n.h2,{id:"deep-dive-into-ros-2-communication-mechanisms",children:"Deep Dive into ROS 2 Communication Mechanisms"}),"\n",(0,i.jsxs)(n.p,{children:["In the previous chapter, we introduced the fundamental concepts of ROS 2 communication. Now, let's explore ",(0,i.jsx)(n.strong,{children:"Nodes"}),", ",(0,i.jsx)(n.strong,{children:"Topics"}),", ",(0,i.jsx)(n.strong,{children:"Services"}),", and ",(0,i.jsx)(n.strong,{children:"Actions"})," in greater detail, providing practical Python examples to illustrate their usage. Understanding these mechanisms is crucial for building any non-trivial ROS 2 application."]}),"\n",(0,i.jsx)(n.h3,{id:"1-nodes-the-building-blocks-of-your-robot-application",children:"1. Nodes: The Building Blocks of Your Robot Application"}),"\n",(0,i.jsx)(n.p,{children:"As discussed, a node is an executable process that performs a specific computation. In ROS 2, applications are typically composed of many small, focused nodes rather than one monolithic program."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: A Minimal ROS 2 Node in Python"})}),"\n",(0,i.jsx)(n.p,{children:"Let's create a simple node that just initializes itself and logs a message."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# minimal_node.py\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n    def __init__(self):\n        super().__init__('minimal_node') # Initialize the node with the name 'minimal_node'\n        self.get_logger().info('MinimalNode has been started!')\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize the ROS 2 client library\n    node = MinimalNode()\n    rclpy.spin(node) # Keep the node alive until it's explicitly shutdown\n    node.destroy_node() # Clean up when the node is destroyed\n    rclpy.shutdown() # Shutdown the ROS 2 client library\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To run this node, you would typically use ",(0,i.jsx)(n.code,{children:"ros2 run <package_name> minimal_node"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"2-topics-asynchronous-data-streaming-publishsubscribe",children:"2. Topics: Asynchronous Data Streaming (Publish/Subscribe)"}),"\n",(0,i.jsx)(n.p,{children:"Topics are the most common way for nodes to exchange data asynchronously. One node publishes messages to a topic, and any number of other nodes can subscribe to that topic to receive those messages."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: Publisher and Subscriber Nodes"})}),"\n",(0,i.jsx)(n.p,{children:'Let\'s create a talker (publisher) that sends "Hello ROS 2!" messages and a listener (subscriber) that receives them.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Talker Node (",(0,i.jsx)(n.code,{children:"talker.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String # Standard message type for strings\n\nclass Talker(Node):\n    def __init__(self):\n        super().__init__('talker')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10) # Topic: 'chatter', QoS: 10\n        timer_period = 0.5 # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello ROS 2! {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    talker_node = Talker()\n    rclpy.spin(talker_node)\n    talker_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Listener Node (",(0,i.jsx)(n.code,{children:"listener.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Listener(Node):\n    def __init__(self):\n        super().__init__('listener')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10) # Topic: 'chatter', QoS: 10\n        self.subscription # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    listener_node = Listener()\n    rclpy.spin(listener_node)\n    listener_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-services-synchronous-requestreply",children:"3. Services: Synchronous Request/Reply"}),"\n",(0,i.jsx)(n.p,{children:"Services are used for operations where a client needs an immediate response from a server."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: Add Two Integers Service"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's define a service that adds two integers. First, you'd define a custom service message (e.g., in ",(0,i.jsx)(n.code,{children:"<package_name>/srv/AddTwoInts.srv"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# AddTwoInts.srv\nint64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then, generate Python interfaces (covered in next chapter). After generation:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Service Server Node (",(0,i.jsx)(n.code,{children:"add_two_ints_server.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom your_package_name.srv import AddTwoInts # Custom service message\n\nclass AddTwoIntsService(Node):\n    def __init__(self):\n        super().__init__('add_two_ints_server')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Add two ints service ready.')\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sending back: sum={response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = AddTwoIntsService()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Service Client Node (",(0,i.jsx)(n.code,{children:"add_two_ints_client.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom your_package_name.srv import AddTwoInts\nimport sys\n\nclass AddTwoIntsClient(Node):\n    def __init__(self):\n        super().__init__('add_two_ints_client')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        # Wait for service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future) # Wait for response\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    client_node = AddTwoIntsClient()\n    if len(sys.argv) != 3:\n        client_node.get_logger().error('Usage: ros2 run your_package_name add_two_ints_client A B')\n        rclpy.shutdown()\n        sys.exit(1)\n    \n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n    \n    response = client_node.send_request(a, b)\n    if response:\n        client_node.get_logger().info(f'Result of {a} + {b} = {response.sum}')\n    else:\n        client_node.get_logger().error('Service call failed!')\n\n    client_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-actions-asynchronous-long-running-tasks-with-feedback",children:"4. Actions: Asynchronous, Long-Running Tasks with Feedback"}),"\n",(0,i.jsx)(n.p,{children:'Actions are ideal for tasks like "move to a goal" where you need to track progress and potentially cancel the operation. Actions define a goal, result, and feedback.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: Simple 'Count Up' Action"})}),"\n",(0,i.jsxs)(n.p,{children:["First, you'd define a custom action message (e.g., in ",(0,i.jsx)(n.code,{children:"<package_name>/action/CountUp.action"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# CountUp.action\nint32 target_number\n---\nint32 final_count\n---\nint32 current_count\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Action Server Node (",(0,i.jsx)(n.code,{children:"count_up_action_server.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom your_package_name.action import CountUp # Custom action message\nimport time\n\nclass CountUpActionServer(Node):\n    def __init__(self):\n        super().__init__('count_up_action_server')\n        self._action_server = ActionServer(\n            self,\n            CountUp,\n            'count_up',\n            self.execute_callback)\n        self.get_logger().info('Count up action server ready.')\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        feedback_msg = CountUp.Feedback()\n        \n        for i in range(goal_handle.request.target_number):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled!')\n                return CountUp.Result()\n            \n            feedback_msg.current_count = i + 1\n            self.get_logger().info(f'Feedback: {feedback_msg.current_count}')\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(1) # Simulate work\n\n        goal_handle.succeed()\n        result = CountUp.Result()\n        result.final_count = goal_handle.request.target_number\n        self.get_logger().info('Goal succeeded!')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CountUpActionServer()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Action Client Node (",(0,i.jsx)(n.code,{children:"count_up_action_client.py"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom your_package_name.action import CountUp\nimport time\n\nclass CountUpActionClient(Node):\n    def __init__(self):\n        super().__init__('count_up_action_client')\n        self._action_client = ActionClient(self, CountUp, 'count_up')\n\n    def send_goal(self, target_number):\n        goal_msg = CountUp.Goal()\n        goal_msg.target_number = target_number\n\n        self._action_client.wait_for_server()\n        self.get_logger().info('Action server found. Sending goal...')\n        \n        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected!')\n            return\n\n        self.get_logger().info('Goal accepted!')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: Final Count = {result.final_count}')\n        rclpy.shutdown()\n\n    def feedback_callback(self, feedback_msg):\n        self.get_logger().info(f'Received feedback: Current Count = {feedback_msg.current_count}')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    client_node = CountUpActionClient()\n    client_node.send_goal(5) # Send a goal to count up to 5\n    rclpy.spin(client_node)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"In the next chapter, we will learn how to create your own ROS 2 package, define custom message, service, and action types, and compile your Python nodes to run within the ROS 2 environment."})]})}function _(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);