"use strict";(globalThis.webpackChunkai_book=globalThis.webpackChunkai_book||[]).push([[3967],{7408:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"module4-RAG Systems/metadata-and-embeddings","title":"Module 4.3: Metadata and Embeddings","description":"After ingesting raw text from our documents, the next critical step is to transform this text into a format that a machine can understand for semantic search: embeddings. Alongside this, we must manage metadata to ensure our search results are contextual and useful.","source":"@site/docs/module4-RAG Systems/3-metadata-and-embeddings.mdx","sourceDirName":"module4-RAG Systems","slug":"/module4-RAG Systems/metadata-and-embeddings","permalink":"/physical-ai-robotics-book/docs/module4-RAG Systems/metadata-and-embeddings","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/physical-ai-robotics-book/edit/main/docs/module4-RAG Systems/3-metadata-and-embeddings.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Module 4.3: Metadata and Embeddings"},"sidebar":"tutorialSidebar","previous":{"title":"Module 4.2: Data Ingestion and Processing","permalink":"/physical-ai-robotics-book/docs/module4-RAG Systems/data-ingestion"},"next":{"title":"Module 4.4: Serving the UI with React","permalink":"/physical-ai-robotics-book/docs/module4-RAG Systems/serving-the-ui"}}');var s=a(4848),d=a(8453);const o={sidebar_position:3,title:"Module 4.3: Metadata and Embeddings"},i="Module 4.3: Metadata and Embeddings",r={},c=[{value:"What are Embeddings?",id:"what-are-embeddings",level:2},{value:"The Importance of Metadata",id:"the-importance-of-metadata",level:2},{value:"The Combined Index",id:"the-combined-index",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"module-43-metadata-and-embeddings",children:"Module 4.3: Metadata and Embeddings"})}),"\n",(0,s.jsxs)(t.p,{children:["After ingesting raw text from our documents, the next critical step is to transform this text into a format that a machine can understand for semantic search: ",(0,s.jsx)(t.strong,{children:"embeddings"}),". Alongside this, we must manage ",(0,s.jsx)(t.strong,{children:"metadata"})," to ensure our search results are contextual and useful."]}),"\n",(0,s.jsx)(t.h2,{id:"what-are-embeddings",children:"What are Embeddings?"}),"\n",(0,s.jsxs)(t.p,{children:["An embedding is a numerical representation (a vector) of text, images, or other data. These vectors are designed such that items with similar semantic meanings are closer together in the vector space. For a RAG system, we use an ",(0,s.jsx)(t.strong,{children:"embedding model"})," (e.g., Sentence-BERT, OpenAI's ",(0,s.jsx)(t.code,{children:"text-embedding-ada-002"}),") to convert chunks of our source documents into these vectors."]}),"\n",(0,s.jsx)(t.p,{children:"When a user submits a query, we generate an embedding for the query as well. The retrieval process then becomes a mathematical operation: finding the document vectors that are closest to the query vector. This is far more powerful than keyword matching, as it allows us to find conceptually related information even if the exact words don't match."}),"\n",(0,s.jsx)(t.h2,{id:"the-importance-of-metadata",children:"The Importance of Metadata"}),"\n",(0,s.jsx)(t.p,{children:"While embeddings provide semantic context, metadata provides factual, filterable information about our data. For each document or chunk we index, we should store relevant metadata."}),"\n",(0,s.jsx)(t.p,{children:"Common metadata fields include:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"doc_id"}),": A unique identifier for the document chunk."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"source"}),": The original file path or URL."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"file_type"}),": The type of the document (e.g., PDF, Markdown)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"created_at"}),": The timestamp of when the document was created or indexed."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"chunk_number"}),": If the document is split into multiple parts, this indicates the part number."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["We can design a ",(0,s.jsx)(t.code,{children:"MetadataManager"})," to handle the storage and retrieval of this information. This manager would typically interact with a database (like SQLite, PostgreSQL, or a NoSQL database) to keep the metadata organized."]}),"\n",(0,s.jsx)(t.p,{children:"Here's a Python class representing our metadata structure:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from dataclasses import dataclass, field\nimport datetime\nfrom pathlib import Path\nimport json\n\n@dataclass\nclass Metadata:\n    """A dataclass to hold metadata for each indexed document chunk."""\n    doc_id: str\n    source: str\n    file_type: str\n    created_at: str = field(default_factory=lambda: datetime.datetime.utcnow().isoformat())\n    # Add other relevant fields like author, version, etc.\n\nclass MetadataManager:\n    """Manages the storage and retrieval of metadata in a simple JSON file."""\n    def __init__(self, storage_path: str):\n        self.storage_path = Path(storage_path)\n        if not self.storage_path.exists():\n            with open(self.storage_path, \'w\') as f:\n                json.dump({}, f)\n\n    def add_metadata(self, metadata: Metadata):\n        """Adds a new metadata entry."""\n        with open(self.storage_path, \'r+\') as f:\n            data = json.load(f)\n            data[metadata.doc_id] = metadata.__dict__\n            f.seek(0)\n            json.dump(data, f, indent=4)\n\n    def get_metadata(self, doc_id: str) -> dict | None:\n        """Retrieves metadata for a given document ID."""\n        with open(self.storage_path, \'r\') as f:\n            data = json.load(f)\n            return data.get(doc_id)\n\n# Example Usage:\n# metadata_db = MetadataManager("metadata_storage.json")\n# new_doc_meta = Metadata(doc_id="xyz-123", source="/path/to/doc.pdf", file_type="PDF")\n# metadata_db.add_metadata(new_doc_meta)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"the-combined-index",children:"The Combined Index"}),"\n",(0,s.jsxs)(t.p,{children:["Our final index, often stored in a specialized ",(0,s.jsx)(t.strong,{children:"vector database"})," (like Chroma, Pinecone, or Weaviate), contains two key components for each entry:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"The Embedding Vector:"})," The numerical representation of the document chunk."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"The Metadata Payload:"})," The associated metadata (doc_id, source, etc.)."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:['This combined structure allows us to perform powerful queries. For instance, we could search for "safety protocols" but filter the results to only include documents that are of ',(0,s.jsx)(t.code,{children:"file_type: PDF"})," and were created in the last year. This filtering at the retrieval stage makes the entire RAG pipeline more efficient and accurate."]})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var n=a(6540);const s={},d=n.createContext(s);function o(e){const t=n.useContext(d);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(d.Provider,{value:t},e.children)}}}]);